---
title: "Creating a Custom Function to Calculate Indices"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{custom-indices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(eemanalyzeR)
```

## Introduction

To maximum flexibility in calculating indices, we've enabled the [get_indices](../html/get-indices.html) function to accept custom written functions, allowing users to create their own function and calculate indices that may not be included in existing methods.

## Function Requirements

1.  The function needs to have the following arguments:
    a.  eemlist: an eemlist object containing EEM's data.
    b.  abslist: an abslist object containing absorbance data.
    c.  cuvle: the cuvette (path) length in cm.
2.  The function must return a list with the following items:
    a.  abs_index: the indices calculated from the absorbance data
    b.  eem_index: the indices calculated from the EEMs data

abs_index and eem_index should both be a data.frame with the following columns:

-   sample_name: a character, the name of the sample

-   meta_name: a character, the name of the sample in the metadata if metadata has been added, otherwise the sample name again

-   index: a character, the name of the index being reported

-   value: the value of the index, also accepts flag values (see details below)

## Helper Functions

The eemanalyzeR package contains a number of functions helpful in creating custom indices.

To get the absorbance values at a certain wavelength the [get_absorbance](../html/get-absorbance.html) function can be used. This function can additionally provide specific absorbance (like SUVA 254).

```{r}
#add metadata to get DOC values
abslist <- add_metadata(metadata, example_absorbance)

#absorbance at 254 nm
a254 <- eemanalyzeR::get_absorbance(abslist, 254) 
a254 

#specific absorbance at 254 nm
suva254 <- eemanalyzeR::get_absorbance(abslist, 254, suva=TRUE) 
suva254
```

A similar function exists for getting fluorescence values from EEMs data: [get_fluorescence](../html/get-fluorescence.html). Here, you can specify a range of excitation and/or emission wavelengths. If stat is set to `sum` the sum of fluorescence will be returned, otherwise if `max` is used the maximum fluorescence across that range will be returned.

```{r}
#get maximum fluorescence across ranges for Peak A and D
pA <- get_fluorescence(example_eems, ex=250:260, em=380:480, stat="max")
pA
pD <- get_fluorescence(example_eems, ex=390, em=509, stat="max")
pD 

#get sum of fluorescence across range of Peak A
pA_sum <- get_fluorescence(example_eems, ex=250:260, em=380:480, stat="sum")
pA_sum
```

Lastly, we have a function for getting spectral slopes: [get_abs_slope](../html/get-abs-slope.html) which will convert the absorbance to absorption, interpolate the data if needed, and return the spectral slope within a wavelength range. 
```{r}
S275_295 <- get_abs_slope(example_absorbance, lim=c(275,295))

```

## QA/QC Flags

While the [get_indices](../html/get-indices.html) function includes some QA/QC checks (negative numbers, missing values, below noise, outside expected range, etc.), there are some checks that are easier to do when calculating the indices, or you may wish to include custom flags or checks. To pass flags from your index function to the output, they need to get put in the `value` column of the index data.frames.

There are a few rules to follow with flags:

1.  Flags should have the form text## (DOC01, DATA04, etc.)

2.  If an index value is NA and you want to flag with a reason why it is NA, replace the NA value with that flag value.

3.  If you wish to report a value, but still include a flag, report the value in the form: value_flag (0.042_DATA01, 43.1_DOC01, etc.)

### Helper Functions

There are few helper functions within the eemanalyzeR package that will provide some common flags.

First is the [get_ratios](../html/get-ratios.html) function. This can be helpful when calculating things like peak ratios, where a missing value will result in an `NA` or a value of 0 in the denominator will result in an infinite value.

```{r}
#calculate the ratio of Peak A to Peak T
 pA <- get_fluorescence(example_eems, ex=250:260, em=380:480)
 pT <- get_fluorescence(example_eems, ex=270:280, em=320:350)
 rAT <- get_ratios(pA, pT)
 rAT
 
  #if Peak T is all 0, will return DATA_03 flag, indicating index couldn't 
    #calculated due to zero in denominator
    rAT <- get_ratios(pA, 0)
    rAT
 
#calculate HIX 
  sum_high <- get_fluorescence(example_eems, ex=254, em=435:480, stat = "sum")
  sum_low <- get_fluorescence(example_eems, ex=254, em=300:345, stat="sum")
  HIX <- get_ratios(sum_high,sum_low)
  HIX
  
  #if sum_low is NA, will return DATA_01 flag indicating the index couldn't be 
    #calculated due to missing data
    HIX <- get_ratios(sum_high, NA)
    HIX

```

There's also a function that will flag indices that can't be calculated because data didn't exist for the requested wavelengths: [flag_missing](../html/flag-missing.html). This is useful to check when calculating indices to flag why certain indices might be returning `NA` values.

```{r}
#checking absorbance data
  #data exists, so there are no flags, NA is returned
  flag_missing(example_absorbance, wl=400) 

 #data doesn't exist
  flag_missing(example_absorbance, wl=100)
  
 #some data exists, still calculate
  flag_missing(example_absorbance, wl=100:254, all=FALSE)

#checking fluorescence data
  #data exists, so there are no flags, NA is returned
  flag_missing(example_eems, ex=270:280, em=300:320) 
  
  #data doesn't exist
  flag_missing(example_eems, ex=100:150, em=300:320) 
  
  #some data exists, still calculate
  flag_missing(example_eems, ex=100:350, em=300:320, all=FALSE) 
```

Once we've gotten the values and the flags, the data needs to be formatted in a specific way to input into the [get_indices](../html/get-indices.html) function. To do this we can use the [format_index](../html/format-index.html) function.

```{r}
  ex <- 240:260
  em <- 300:320
  vals <- get_fluorescence(example_eems, ex, em, stat = "max")
  flags <- flag_missing(example_eems, ex=ex, em=em, all=FALSE)
  index_formatted <- format_index(example_eems, "test_index", vals, flags)
  index_formatted
```

## Example 1

Alright, now that we've reviewed all the helper functions and the requirements for the custom function let's do an example. Let's create a custom function to calculate the maximum fluorescence for the five regions defined in Chen et al. 2003:

```{r echo=FALSE, include=TRUE}
indices <- data.frame(region=c("I", "II", "III", "IV", "V"), 
                      excitation=c("<250", "<250", "<250", ">250", ">250"),
                      emission=c("<300","330-380", ">380", "<380",">380"))

colnames(indices) <- c("Region", "Excitation (nm)", "Emission (nm)")
knitr::kable(indices)
```

First let's turn the different regions into a list of excitation and emission wavelengths.

```{r}
chen_regions <- list(r1 = list(ex=240:250, em=245:300),
                     r2 = list(ex=240:250, em=330:380),
                     r3 = list(ex=240:250, em=380:550),
                     r4 = list(ex=250:800, em=245:380),
                     r5 = list(ex=250:800, em=380:550))
```

We can use the [get_fluorescence](../html/get-fluorescence.html) helper function to calculate the maximum fluorescence in these regions. For a single region that would look like:

```{r}
get_fluorescence(example_eems, chen_regions[[1]]$ex, chen_regions[[1]]$em, stat="max")

```
To get all the indices let's use the lapply function. 

```{r}
results <- lapply(names(chen_regions), function(region_name) {
  region <- chen_regions[[region_name]]
  get_fluorescence(example_eems, region$ex, region$em, stat = "max")
  })

```

While we're calculating each index, let's also use the [flag_missing](../html/flag-missing.html) function to see if there's any data missing. Since we're finding the maximum value, we'll set `all` to `FALSE` so it will report a value if there's some data. Lastly, we'll use the [format_index](../html/format-index.html) function to make sure everything is correctly formatted.

```{r}
results <- lapply(names(chen_regions), function(region_name){
  #get values
  region <- chen_regions[[region_name]]
  vals <- get_fluorescence(example_eems, region$ex, region$em, stat = "max")

  #get flags
  flags <- flag_missing(example_eems, ex=region$ex, em=region$em, all=FALSE)

  #add sample names and make into data.frame (get index name)
  res <- format_index(example_eems, region_name, vals, flags)
    
  #return res
  return(res)
  })

results <- do.call(rbind, results)
```


Lastly, we just need to return the results as a list. Since we don't have any absorbance data we'll just make it NA.
```{r}
  list(abs_index = NA,
       eem_index=results)
```

Great, that all looks good, now we just need to combine all that code to a custom function. 
```{r}
chen2003 <- function(eemlist, abslist, cuvle=1){
  #making sure eemlist and abslist are correct objects
    stopifnot(.is_eemlist(eemlist), .is_abslist(abslist), is.numeric(cuvle), all(sapply(eemlist, attr, "is_doc_normalized"))==FALSE)
  #specify regions
    chen_regions <- list(r1 = list(ex=240:250, em=245:300),
                     r2 = list(ex=240:250, em=330:380),
                     r3 = list(ex=240:250, em=380:550),
                     r4 = list(ex=250:800, em=245:380),
                     r5 = list(ex=250:800, em=380:550))
  
  #get results as a data.frame
    results <- lapply(names(chen_regions), function(region_name){
    #get values
    region <- chen_regions[[region_name]]
    vals <- get_fluorescence(eemlist, region$ex, region$em, stat = "max")
  
    #get flags
    flags <- flag_missing(eemlist, ex=region$ex, em=region$em, all=FALSE)
  
    #add sample names and make into data.frame (get index name)
    res <- format_index(eemlist, region_name, vals, flags)
      
    #return res
    return(res)
    })
  
  #combine lists together
    results <- do.call(rbind, results)

  return(list(abs_index = NA,
         eem_index=results))
}
```

Now let's test our custom function with the [get_indices](../html/get-indices.html) function. Note that we get a warning about the indices because the EEMs data hasn't gone through any processing steps. 
```{r}
indices <- get_indices(example_eems, example_absorbance, index_method = chen2003, return = "wide")

indices$eem_index
```

## Example 2 
The last example only used fluorescence data. Let's create another custom function focused on absorbance indices. We'll create a function to calculate the indices used in Erlandsson et al. 2012: 

```{r echo=FALSE, include=TRUE}
indices <- data.frame(index=c("a254", "a420", "a220_a254", "a250_a364", "a300_a400",
                              "S275_295","SR"), 
                      description=c("absorbance at 254 nm", "absorbance at 420 nm", 
                                    "ratio of absorbance at 220 to 254 nm",
                                    "ratio of absorbance at 250 to 364 nm", 
                                    "ratio of absorbance at 300 to 400 nm",
                                    "spectral slope between 275 to 295 nm",
                                    "spectral ratio"))

colnames(indices) <- c("Index", "Description")
knitr::kable(indices)
```

First let's turn the indices into a list of wavelengths to help with flagging and calculating. Note that for the ratios we only need two specific wavelengths, so we're making that a vector of just those two wavelengths, while the spectral slope needs all the wavelengths between those two values, so we're making that a vector of all the wavelengths between those two wavelengths.

```{r}
erlandsson_index <- list(a254=254,
                         a420=420,
                         a220_a254=c(220,250),
                         a254_a364=c(254,364),
                         a300_a400=c(300,400),
                         S275_295=c(275:295),
                         SR=c(275:295, 350:400))
```

We can use the [get_absorbance](../html/get-absorbance.html) helper function to calculate the absorbance at 254 and 420. For a single wavelength that looks like: 

```{r}
a254 <- get_absorbance(example_absorbance, wl=erlandsson_index[[1]])
a254

```
Let's use lapply to get the absorbance, add any flags, and format it correctly. We'll use `do.call` to bind all the lists of indices together.

```{r}
abs_data <- lapply(names(erlandsson_index[1:2]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       vals <- get_absorbance(example_absorbance, wl=index) 
       
       #get flags
        flags <- flag_missing(example_absorbance, wl=index, all=TRUE)

      #add sample names and make into data.frame (get index name)
        res <- format_index(example_absorbance, index_name, vals, flags)

        #return res
        return(res)
     })
abs_data <- do.call(rbind, abs_data)
```


Next lets get the ratios, we can still use the [get_absorbance](../html/get-absorbance.html) helper function to get the absorbance at the wavelengths, and then use the [get_ratios](../html/get-ratios.html) helper function to get the ratio with any flags. In the case below, we don't have absorbance at 220 nm, so we get flags of DATA01

```{r}
a220 <- get_absorbance(example_absorbance, wl=220) 
a254 <- get_absorbance(example_absorbance, wl=254)
a220_a254 <- get_ratios(a220, a254)
a220_a254

```

Since we're getting multiple different sets of ratios, let's use lapply to get all of the ratios at once. 

```{r}
ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(example_absorbance, wl=index[1]) 
       a2 <- get_absorbance(example_absorbance, wl=index[2])
       get_ratios(a1, a2)
     })
```

While we're calculating each index, let's also use the [flag_missing](../html/flag-missing.html) function to see if there's any data missing. Lastly, we'll use the [format_index](../html/format-index.html) function to make sure everything is correctly formatted. We'll use `do.call` to bind all the lists of indices together. 

```{r}
ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(example_absorbance, wl=index[1]) 
       a2 <- get_absorbance(example_absorbance, wl=index[2])
       vals <- get_ratios(a1, a2)
       
       #get flags
        flags <- flag_missing(example_absorbance, wl=index)

      #add sample names and make into data.frame (get index name)
      res <- format_index(example_absorbance, index_name, vals, flags)
        
      #return res
      return(res)
     })
ratios <- do.call(rbind, ratios)
```

Lastly we need to get the spectral slopes and spectral ratio. For these we'll use the [get_abs_slope](../html/get-abs-slope.html) function. 
```{r}
index <- "S275_295"
vals <- get_abs_slope(example_absorbance, c(275,295))
flags <- flag_missing(example_absorbance, wl=erlandsson_index[[index]])
S275_295 <- format_index(example_absorbance, index, vals, flags)

index <- "SR"
vals <- get_ratios(get_abs_slope(example_absorbance, c(275,295)), get_abs_slope(example_absorbance, c(350,400)))
flags <- flag_missing(example_absorbance, wl=erlandsson_index[[index]])
SR <- format_index(example_absorbance, index, vals, flags)

```


Lastly, we just need to combine all the indices into a data.frame and return the results as a list using another `do.call`. Since we don't have any EEMs data we'll just make it NA.
```{r}
 results <- do.call(rbind, list(abs_data, ratios, S275_295, SR))

 list(abs_index = results,
       eem_index=NA)
```

Great, that all looks good, now we just need to combine all that code to a custom function. 
```{r}
erlandsson2012 <- function(eemlist, abslist, cuvle=1){
  #making sure eemlist and abslist are correct objects
    stopifnot(.is_eemlist(eemlist), .is_abslist(abslist), is.numeric(cuvle), all(sapply(eemlist, attr, "is_doc_normalized"))==FALSE)
  
  #specify wavelengths
    erlandsson_index <- list(a254=254,
                         a420=420,
                         a220_a254=c(220,250),
                         a254_a364=c(254,364),
                         a300_a400=c(300,400),
                         S275_295=c(275:295),
                         SR=c(275:295, 350:400))
  
  #get results as a data.frame
    abs_data <- lapply(names(erlandsson_index[1:2]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       vals <- get_absorbance(abslist, wl=index) 
       
       #get flags
        flags <- flag_missing(abslist, wl=index, all=TRUE)

      #add sample names and make into data.frame (get index name)
        res <- format_index(abslist, index_name, vals, flags)

        #return res
        return(res)
     })
    abs_data <- do.call(rbind, abs_data)
  
    ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(abslist, wl=index[1]) 
       a2 <- get_absorbance(abslist, wl=index[2])
       vals <- get_ratios(a1, a2)
       
       #get flags
        flags <- flag_missing(abslist, wl=index)

      #add sample names and make into data.frame (get index name)
      res <- format_index(abslist, index_name, vals, flags)
        
      #return res
      return(res)
     })
    ratios <- do.call(rbind, ratios) 
    
    index <- "S275_295"
    vals <- get_abs_slope(abslist, c(275,295))
    flags <- flag_missing(abslist, wl=erlandsson_index[[index]])
    S275_295 <- format_index(abslist, index, vals, flags)
    
    index <- "SR"
    vals <- get_ratios(get_abs_slope(abslist, c(275,295)), get_abs_slope(abslist, c(350,400)))
    flags <- flag_missing(abslist, wl=erlandsson_index[[index]])
    SR <- format_index(abslist, index, vals, flags)


  #combine lists together
    results <- do.call(rbind, list(abs_data, ratios, S275_295, SR))


  return(list(abs_index = results,
       eem_index=NA))
}
```

Now let's test our custom function with the [get_indices](../html/get-indices.html) function. Once again note that we get a warning about the indices because the EEMs data hasn't gone through any processing steps.  
```{r}
indices <- get_indices(example_eems, example_absorbance, index_method = erlandsson2012, return="wide")

indices$abs_index
```


## References

Chen, W., Westerhoff, P., Leenheer, J. A., & Booksh, K. (2003). Fluorescence excitation-emission matrix regional integration to quantify spectra for dissolved organic matter. Environmental Science & Technology, 37(24), 5701–5710. <https://doi.org/10.1021/es034354c> 

Erlandsson, M., N. Futter, M., N. Kothawala, D., & J. Köhler, S. (2012). Variability in spectral absorbance metrics across boreal lake waters. Journal of Environmental Monitoring, 14(10), 2643-2652. <https://doi.org/10.1039/C2EM30266G>

