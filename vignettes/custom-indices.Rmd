---
title: "Creating a Custom Function to Calculate Indices"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating a Custom Function to Calculate Indices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(eemanalyzeR)
```

## Introduction

To maximum flexibility in calculating indices, we've enabled the [get_indices](../html/get-indices.html) function to accept custom written functions, allowing users to create their own function and calculate indices that may not be included in existing methods.

## Function Requirements

1.  **The function needs to have the following arguments:**
    a.  `eemlist`: an eemlist object containing EEM's data.
    b.  `abslist`: an abslist object containing absorbance data.
    c.  `cuvle`: the cuvette (path) length in cm.
    d.  `mdl_dir`: the file path to the mdl files generated with \link[eemanalyzeR]{create_mdl}
2.  **The function must return a list with the following items:**
    a.  `abs_index`: the indices calculated from the absorbance data
    b.  `eem_index`: the indices calculated from the EEMs data

`abs_index` and `eem_index` should both be a data.frame with the following columns:

-   `sample_name`: a character, the name of the sample

-   `meta_name`: a character, the name of the sample in the metadata if metadata has been added, otherwise the sample name again

-   `index`: a character, the name of the index being reported

-   `value`: the value of the index, also accepts flag values (see details below)

## Helper Functions

**The eemanalyzeR package contains a number of functions helpful in creating custom indices.**

To get the absorbance values at a certain wavelength the [get_absorbance](../html/get-absorbance.html) function can be used. This function can additionally provide specific absorbance (like SUVA 254).

```{r}
abslist <- example_processed_abs

#absorbance at 254 nm
a254 <- eemanalyzeR::get_absorbance(abslist, 254) 
a254 

#specific absorbance at 254 nm
suva254 <- eemanalyzeR::get_absorbance(abslist, 254, suva=TRUE) 
suva254
```

A similar function exists for getting fluorescence values from EEMs data: [get_fluorescence](../html/get-fluorescence.html). Here, you can specify a range of excitation and/or emission wavelengths. If stat is set to `sum` the sum of fluorescence will be returned, otherwise if `max` is used the maximum fluorescence across that range will be returned.

```{r}

eemlist <- example_processed_eems

#get maximum fluorescence across ranges for Peak A and D
pA <- get_fluorescence(eemlist, ex=250:260, em=380:480, stat="max")
pA
pD <- get_fluorescence(eemlist, ex=390, em=509, stat="max")
pD 

#get sum of fluorescence across range of Peak A
pA_sum <- get_fluorescence(eemlist, ex=250:260, em=380:480, stat="sum")
pA_sum
```

Lastly, we have a function for getting spectral slopes: [get_abs_slope](../html/get-abs-slope.html) which will convert the absorbance to absorption, interpolate the data if needed, and return the spectral slope within a wavelength range.

```{r}
S275_295 <- get_abs_slope(abslist, lim=c(275,295))

```

## QA/QC Flags

While the [get_indices](../html/get-indices.html) function includes some QA/QC checks (negative numbers, missing values, below noise, outside expected range, etc.), there are some checks that are easier to do when calculating the indices, or you may wish to include custom flags or checks. To pass flags from your index function to the output, they need to get put in the `value` column of the index data.frames.

There are a few rules to follow with flags:

1.  Flags should have the form text## (DOC01, DATA04, etc.)

2.  If an index value is NA and you want to flag with a reason why it is NA, replace the NA value with that flag value.

3.  If you wish to report a value, but still include a flag, report the value in the form: value_flag (0.042_DATA01, 43.1_DOC01, etc.)

### Helper Functions

There are few helper functions within the **eemanalyzeR** package that will provide some common flags.

First is the [get_ratios](../html/get-ratios.html) function. This can be helpful when calculating things like peak ratios, where a missing value will result in an `NA` or a value of 0 in the denominator will result in an infinite value.

```{r}
#calculate the ratio of Peak A to Peak T
 pA <- get_fluorescence(eemlist, ex=250:260, em=380:480)
 pT <- get_fluorescence(eemlist, ex=270:280, em=320:350)
 rAT <- get_ratios(pA, pT)
 rAT
 
  #if Peak T is all 0, will return DATA_03 flag, indicating index couldn't 
    #calculated due to zero in denominator
    rAT <- get_ratios(pA, 0)
    rAT
 
#calculate HIX 
  sum_high <- get_fluorescence(eemlist, ex=254, em=435:480, stat = "sum")
  sum_low <- get_fluorescence(eemlist, ex=254, em=300:345, stat="sum")
  HIX <- get_ratios(sum_high,sum_low)
  HIX
  
  #if sum_low is NA, will return DATA_01 flag indicating the index couldn't be 
    #calculated due to missing data
    HIX <- get_ratios(sum_high, NA)
    HIX

```

There's also a function that will flag indices that can't be calculated because data didn't exist for the requested wavelengths: [flag_missing](../html/flag-missing.html). This is useful to check when calculating indices to flag why certain indices might be returning `NA` values.

```{r}
#checking absorbance data
  #data exists, so there are no flags, NA is returned
  flag_missing(abslist, wl=400) 

 #data doesn't exist
  flag_missing(abslist, wl=100)
  
 #some data exists, still calculate
  flag_missing(abslist, wl=100:254, all=FALSE)

#checking fluorescence data
  #data exists, so there are no flags, NA is returned
  flag_missing(eemlist, ex=270:280, em=300:320) 
  
  #data doesn't exist
  flag_missing(eemlist, ex=100:150, em=300:320) 
  
  #some data exists, still calculate
  flag_missing(eemlist, ex=100:350, em=300:320, all=FALSE) 
```
You may also want to flag values below the method detection limit (MDL) this can be done with: [check_*_mdl](../html/check-mdl.html). This is useful to ensure that the blanks are actually blank and ratio values that are returned are based on "real" data. 

```{r}
#checking absorbance data
  #get mdl 
    abs_mdl <- readRDS(file.path(system.file("extdata", package = "eemanalyzeR"), 
                                 "abs-mdl.rds"))

  #data is fully above the MDL so NA is returned 
    check_abs_mdl(abslist[[2]], abs_mdl, wl=254)
    
  #data is fully below the MDL so MDL01 is returned
    check_abs_mdl(abslist[[1]], abs_mdl, wl=254)
    
#checking fluorescence data
  #get mdl 
    eem_mdl <- readRDS(file.path(system.file("extdata", package = "eemanalyzeR"), 
                                 "eem-mdl.rds"))
    
  #data is completely above the MDL so NA is returned
   check_eem_mdl(eemlist[[2]], mdl = eem_mdl, ex=270:280, em=300:320)
    
  #data is fully below the MDL so MDL01 is returned
   check_eem_mdl(eemlist[[1]], mdl = eem_mdl, ex=270:280, em=300:320)

  #some of the data is below the MDL so MDL02 is returned
    eemlist[[2]]$x[1,4] <- 0.000001 #set a low value so it spans the MDL in the region for an example
    check_eem_mdl(eemlist[[2]], mdl = eem_mdl, ex = 314, em=250:262)


```
If your function generates more than one flag (say a flag for missing data and an MDL flag) you can use the [.combine_flags](../html/dot-combine-flags.html) function to nicely combine the flags. 

```{r}
  #works with a single set of flags 
    .combine_flags("DATA01", NA)
    .combine_flags(NA, "MDL01")
    .combine_flags(NA, NA)
    .combine_flags("DATAO1", "MDL01")
    .combine_flags("DATA01", "DATA01")
  
  #also works with a vector of flags 
    flag1 <- c("MDL01", "MDL02", NA)
    flag2 <- c("DATA01", NA, NA)
    .combine_flags(flag1, flag2)
    
  #if you set MDL to TRUE, it knows it's combining two MDL flags 
    #so if one is MDL01 and one is MDL02, it will return MDL02, some of the 
    #data was below the MDL 
    #this function is useful for indices using ratios
    .combine_flags("MDL01", "MDL02", mdl=TRUE)
```
Once we've gotten the values and the flags, the data needs to be formatted in a specific way to input into the [get_indices](../html/get-indices.html) function. To do this we can use the [format_index](../html/format-index.html) function.

```{r}
  ex <- 240:260
  em <- 300:320
  vals <- get_fluorescence(eemlist, ex, em, stat = "max")
  flags <- flag_missing(eemlist, ex=ex, em=em, all=FALSE)
  index_formatted <- format_index(eemlist, "test_index", vals, flags)
  index_formatted
```

## Example 1

Alright, now that we've reviewed all the helper functions and the requirements for the custom function let's do an example. Let's create a custom function to calculate some new fluorescence indices presented in **Zhang et al. 2025:**

$$ \text{U-SoI} =\frac{U1_{ex:245, em:440}}{U2_{ex:230, em:260}}  $$ 

$$ \text{A-SoI} =\frac{A1_{ex:245, em:325}}{A2_{ex:260, em:430}}  $$

$$ \text{T-SoI} =\frac{T1_{ex:260, em:430}}{T2_{ex:285, em:365}}  $$

First let's turn the different indices into a list of excitation and emission wavelengths.

```{r}
zhang_indices <- list(USoI = list(ex=c(245,230), em=c(440,260)),
                     ASoI = list(ex=c(245,260), em=c(325,430)),
                     TSoI = list(ex=c(260,285), em=c(430,365)))
```

We can use the [get_fluorescence](../html/get-fluorescence.html) helper function to calculate the fluorescence for the numerator and denominator of the ratio. Then we can use the [get_ratios](../html/get-ratios.html) helper function to get the ratio. For a single index this would look like:

```{r}
eemlist <- example_processed_eems
get_ratios(get_fluorescence(eemlist, zhang_indices$TSoI$ex[1], zhang_indices$TSoI$em[1]), 
           get_fluorescence(eemlist, zhang_indices$TSoI$ex[2], zhang_indices$TSoI$em[2]))

```

To get all the indices let's use the lapply function.

```{r}
results <- lapply(names(zhang_indices), function(index_name) {
  index <- zhang_indices[[index_name]]
  get_ratios(get_fluorescence(eemlist, index$ex[1], index$em[1]), 
           get_fluorescence(eemlist, index$ex[2], index$em[2]))
  
  })

```

While we're calculating each index, let's also use the [flag_missing](../html/flag-missing.html) function to see if there's any data missing. Since we're finding the maximum value, we'll set `all` to `FALSE` so it will report a value if there's some data. We'll also check to see if any of the data is below the MDL, since we have two discrete values we can use [.combine_flags](../html/dot-combine-flags.html) to combine the returned MDL flags. Lastly, we'll use the [format_index](../html/format-index.html) function to make sure everything is correctly formatted.

```{r}
results <- lapply(names(zhang_indices), function(index_name){
  #get values
  index <- zhang_indices[[index_name]]
  vals <- get_ratios(get_fluorescence(eemlist, index$ex[1], index$em[1]), 
           get_fluorescence(eemlist, index$ex[2], index$em[2]))

  #get flags
    missflags <- flag_missing(eemlist, ex=index$ex, em=index$em, all=TRUE)
    mdlflags <- .combine_flags(check_eem_mdl(eemlist, eem_mdl, index$ex[1], index$em[1]), 
                               check_eem_mdl(eemlist, eem_mdl, index$ex[2], index$em[2]), mdl=TRUE)
    flags <- .combine_flags(missflags, mdlflags)

  #add sample names and make into data.frame (get index name)
  res <- format_index(eemlist, index_name, vals, flags)
    
  #return res
  return(res)
  })

results <- do.call(rbind, results)
```

Now we need to make sure to add in the MDL data so we can use it to check our values. If the MDL is NULL, we want to have a warning, but still run. 
```{r}
 mdl_dir <- file.path(system.file("extdata", package = "eemanalyzeR"))
 #get mdl data
  check_eem <- file.exists(file.path(mdl_dir, "eem-mdl.rds"))

  #load mdl data or warn
  if(!check_eem){
    warning("fluorescence MDL is missing, indices will not be checked for MDLs")
    eem_mdl <- NULL
    }else{eem_mdl <- readRDS(file.path(mdl_dir, "eem-mdl.rds"))}
```


Lastly, we just need to return the results as a list. Since we don't have any absorbance data we'll just make it NA.

```{r}
  list(abs_index = NA,
       eem_index=results)
```

Great, that all looks good, now we just need to combine all that code to a custom function.

```{r}
zhang2025 <- function(eemlist, abslist, cuvle=1, mdl_dir){
  #making sure eemlist and abslist are correct objects
    stopifnot(.is_eemlist(eemlist), .is_abslist(abslist), is.numeric(cuvle), all(sapply(eemlist, attr, "is_doc_normalized"))==FALSE)
  
  #get mdl data
  check_eem <- file.exists(file.path(mdl_dir, "eem-mdl.rds"))

  #load mdl data or warn
  if(!check_eem){
    warning("fluorescence MDL is missing, indices will not be checked for MDLs")
    eem_mdl <- NULL
  }else{eem_mdl <- readRDS(file.path(mdl_dir, "eem-mdl.rds"))}
  
  #specify indices
    zhang_indices <- list(USoI = list(ex=c(245,230), em=c(440,260)),
                     ASoI = list(ex=c(245,260), em=c(325,430)),
                     TSoI = list(ex=c(260,285), em=c(430,365)))
  
  #get results as a data.frame
   results <- lapply(names(zhang_indices), function(index_name){
      index <- zhang_indices[[index_name]]
      vals <- get_ratios(get_fluorescence(eemlist, index$ex[1], index$em[1]), 
               get_fluorescence(eemlist, index$ex[2], index$em[2]))        
      
      missflags <- flag_missing(eemlist, ex=index$ex, em=index$em, all=TRUE)
      mdlflags <- .combine_flags(check_eem_mdl(eemlist, eem_mdl, index$ex[1], index$em[1]), 
                                   check_eem_mdl(eemlist, eem_mdl, index$ex[2], index$em[2]), mdl=TRUE)
      flags <- .combine_flags(missflags, mdlflags)
    
      res <- format_index(eemlist, index_name, vals, flags)
        
      return(res)
      })

  #combine lists together
    results <- do.call(rbind, results)

  return(list(abs_index = NA,
         eem_index=results))
}
```

Now let's test our custom function with the [get_indices](../html/get-indices.html) function. Note that we get a warning about the indices because the EEMs data hasn't gone through any processing steps.

```{r}
indices <- get_indices(example_processed_eems, example_processed_abs, index_method = zhang2025, return = "wide", 
                       mdl_dir = file.path(system.file("extdata", package = "eemanalyzeR")))

indices$eem_index
```

## Example 2

The last example only used fluorescence data. Let's create another custom function focused on absorbance indices. We'll create a function to calculate the indices used in **Erlandsson et al. 2012:**

```{r echo=FALSE, include=TRUE}
indices <- data.frame(index=c("a254", "a420", "a220_a254", "a250_a364", "a300_a400",
                              "S275_295","SR"), 
                      description=c("absorbance at 254 nm", "absorbance at 420 nm", 
                                    "ratio of absorbance at 220 to 254 nm",
                                    "ratio of absorbance at 250 to 364 nm", 
                                    "ratio of absorbance at 300 to 400 nm",
                                    "spectral slope between 275 to 295 nm",
                                    "spectral ratio"))

colnames(indices) <- c("Index", "Description")
knitr::kable(indices)
```

First let's turn the indices into a list of wavelengths to help with flagging and calculating. Note that for the ratios we only need two specific wavelengths, so we're making that a vector of just those two wavelengths, while the spectral slope needs all the wavelengths between those two values, so we're making that a vector of all the wavelengths between those two wavelengths.

```{r}
erlandsson_index <- list(a254=254,
                         a420=420,
                         a220_a254=c(220,250),
                         a254_a364=c(254,364),
                         a300_a400=c(300,400),
                         S275_295=c(275:295),
                         SR=c(275:295, 350:400))
```

We can use the [get_absorbance](../html/get-absorbance.html) helper function to calculate the absorbance at 254 and 420. For a single wavelength that looks like:

```{r}
abslist <- example_processed_abs
a254 <- get_absorbance(abslist, wl=erlandsson_index[[1]])
a254

```

Let's use lapply to get the absorbance, add any flags, and format it correctly. We'll use `do.call` to bind all the lists of indices together.

```{r}
abs_data <- lapply(names(erlandsson_index[1:2]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       vals <- get_absorbance(abslist, wl=index) 
       
       #get flags
        missflags <- flag_missing(abslist, wl=index, all=TRUE)
        mdlflags <- check_abs_mdl(abslist, abs_mdl, wl=index)
        flags <- .combine_flags(missflags, mdlflags)

      #add sample names and make into data.frame (get index name)
        res <- format_index(abslist, index_name, vals, flags)

        #return res
        return(res)
     })
abs_data <- do.call(rbind, abs_data)
```

Next lets get the ratios, we can still use the [get_absorbance](../html/get-absorbance.html) helper function to get the absorbance at the wavelengths, and then use the [get_ratios](../html/get-ratios.html) helper function to get the ratio with any flags. In the case below, we don't have absorbance at 220 nm, so we get flags of DATA01

```{r}
a220 <- get_absorbance(abslist, wl=220) 
a254 <- get_absorbance(abslist, wl=254)
a220_a254 <- get_ratios(a220, a254)
a220_a254

```

Since we're getting multiple different sets of ratios, let's use lapply to get all of the ratios at once.

```{r}
ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(abslist, wl=index[1]) 
       a2 <- get_absorbance(abslist, wl=index[2])
       get_ratios(a1, a2)
     })
```

While we're calculating each index, let's also use the [flag_missing](../html/flag-missing.html) function to see if there's any data missing. Lastly, we'll use the [format_index](../html/format-index.html) function to make sure everything is correctly formatted. We'll use `do.call` to bind all the lists of indices together.

```{r}
ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(abslist, wl=index[1]) 
       a2 <- get_absorbance(abslist, wl=index[2])
       vals <- get_ratios(a1, a2)
       
        #get flags
        missflags <- flag_missing(abslist, wl=index, all=TRUE)
        mdlflags <- check_abs_mdl(abslist, abs_mdl, wl=index)
        flags <- .combine_flags(missflags, mdlflags)

      #add sample names and make into data.frame (get index name)
      res <- format_index(abslist, index_name, vals, flags)
        
      #return res
      return(res)
     })
ratios <- do.call(rbind, ratios)
```

Lastly we need to get the spectral slopes and spectral ratio. For these we'll use the [get_abs_slope](../html/get-abs-slope.html) function.

```{r}
index <- "S275_295"
vals <- get_abs_slope(abslist, c(275,295))
missflags <- flag_missing(abslist, wl=erlandsson_index[[index]])
mdlflags <- check_abs_mdl(abslist, mdl=abs_mdl, wl=erlandsson_index[[index]])
flags <- .combine_flags(missflags, mdlflags)
S275_295 <- format_index(abslist, index, vals, flags)

index <- "SR"
vals <- get_ratios(get_abs_slope(abslist, c(275,295)), get_abs_slope(abslist, c(350,400)))
missflags <- flag_missing(abslist, wl=erlandsson_index[[index]])
mdlflags <- .combine_flags(check_abs_mdl(abslist, mdl=abs_mdl, wl=275:295),
                           check_abs_mdl(abslist, mdl=abs_mdl, wl=350:400))
flags <- .combine_flags(missflags, mdlflags)
SR <- format_index(abslist, index, vals, flags)

```

Now we need to make sure to add in the MDL data so we can use it to check our values. If the MDL is NULL, we want to have a warning, but still run. 
```{r}
 mdl_dir <- file.path(system.file("extdata", package = "eemanalyzeR"))
 #get mdl data
  check_abs <- file.exists(file.path(mdl_dir, "abs-mdl.rds"))

  #load mdl data or warn
  if(!check_abs){
    warning("absorbance MDL is missing, indices will not be checked for MDLs")
    abs_mdl <- NULL
    }else{abs_mdl <- readRDS(file.path(mdl_dir, "abs-mdl.rds"))}
```


Lastly, we just need to combine all the indices into a data.frame and return the results as a list using another `do.call`. Since we don't have any EEMs data we'll just make it NA.

```{r}
 results <- do.call(rbind, list(abs_data, ratios, S275_295, SR))

 list(abs_index = results,
       eem_index=NA)
```

Great, that all looks good, now we just need to combine all that code to a custom function.

```{r}
erlandsson2012 <- function(eemlist, abslist, cuvle=1, mdl_dir){
  #making sure eemlist and abslist are correct objects
    stopifnot(.is_eemlist(eemlist), .is_abslist(abslist), is.numeric(cuvle), all(sapply(eemlist, attr, "is_doc_normalized"))==FALSE)
  
  #get mdl 
  check_abs <- file.exists(file.path(mdl_dir, "abs-mdl.rds"))

  #load mdl data or warn
  if(!check_abs){
    warning("absorbance MDL is missing, indices will not be checked for MDLs")
    abs_mdl <- NULL
  }else{abs_mdl <- readRDS(file.path(mdl_dir, "abs-mdl.rds"))}
  
  #specify wavelengths
    erlandsson_index <- list(a254=254,
                         a420=420,
                         a220_a254=c(220,250),
                         a254_a364=c(254,364),
                         a300_a400=c(300,400),
                         S275_295=c(275:295),
                         SR=c(275:295, 350:400))
  
  #get results as a data.frame
    abs_data <- lapply(names(erlandsson_index[1:2]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       vals <- get_absorbance(abslist, wl=index) 
       
       #get flags
        missflags <- flag_missing(abslist, wl=index, all=TRUE)
        mdlflags <- check_abs_mdl(abslist, abs_mdl, wl=index)
        flags <- .combine_flags(missflags, mdlflags)
        
      #add sample names and make into data.frame (get index name)
        res <- format_index(abslist, index_name, vals, flags)

        #return res
        return(res)
     })
    abs_data <- do.call(rbind, abs_data)
  
    ratios <- lapply(names(erlandsson_index[3:5]), function(index_name){
       index <- erlandsson_index[[index_name]]

       #get values
       a1 <- get_absorbance(abslist, wl=index[1]) 
       a2 <- get_absorbance(abslist, wl=index[2])
       vals <- get_ratios(a1, a2)
       
        #get flags
        missflags <- flag_missing(abslist, wl=index, all=TRUE)
        mdlflags <- check_abs_mdl(abslist, abs_mdl, wl=index)
        flags <- .combine_flags(missflags, mdlflags)

      #add sample names and make into data.frame (get index name)
      res <- format_index(abslist, index_name, vals, flags)
        
      #return res
      return(res)
     })
    ratios <- do.call(rbind, ratios) 
    
    index <- "S275_295"
    vals <- get_abs_slope(abslist, c(275,295))
    missflags <- flag_missing(abslist, wl=erlandsson_index[[index]])
    mdlflags <- check_abs_mdl(abslist, mdl=abs_mdl, wl=erlandsson_index[[index]])
    flags <- .combine_flags(missflags, mdlflags)
    S275_295 <- format_index(abslist, index, vals, flags)
    
    index <- "SR"
    vals <- get_ratios(get_abs_slope(abslist, c(275,295)), get_abs_slope(example_processed_abs, c(350,400)))
    missflags <- flag_missing(abslist, wl=erlandsson_index[[index]])
    mdlflags <- .combine_flags(check_abs_mdl(abslist, mdl=abs_mdl, wl=275:295),
                               check_abs_mdl(abslist, mdl=abs_mdl, wl=350:400))
    flags <- .combine_flags(missflags, mdlflags)
    SR <- format_index(abslist, index, vals, flags)

  #combine lists together
    results <- do.call(rbind, list(abs_data, ratios, S275_295, SR))


  return(list(abs_index = results,
       eem_index=NA))
}
```

Now let's test our custom function with the [get_indices](../html/get-indices.html) function. Once again note that we get a warning about the indices because the EEMs data hasn't gone through any processing steps.

```{r}
indices <- get_indices(example_processed_eems, example_processed_abs, index_method = erlandsson2012, 
                       mdl_dir = file.path(system.file("extdata", package = "eemanalyzeR")), return="wide")

indices$abs_index
```

## References

Zhang, H., Hou, J., Nie, L., Hao, Y., Gao, H., & Yu, H. (2025). Developing new spectral indices for identifying DOM sources in Liaohe River in a large-scale river basin by fluorescence spectroscopy and random forest model. Process Safety and Environmental Protection, 201, 107553. <https://doi.org/10.1016/j.psep.2025.107553>

Erlandsson, M., N. Futter, M., N. Kothawala, D., & J. Köhler, S. (2012). Variability in spectral absorbance metrics across boreal lake waters. Journal of Environmental Monitoring, 14(10), 2643-2652. <https://doi.org/10.1039/C2EM30266G>
